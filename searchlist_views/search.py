from django.http import Http404, HttpResponse

from django.views.generic.base import View
from django.views.generic.list import ListView
from django.views.generic.edit import FormView, FormMixin
from django.views.generic.list import ListView, BaseListView
from django.views.generic.base import TemplateResponseMixin
from django.db.models import Q
from django.utils.decorators import method_decorator
from django.contrib.auth.decorators import login_required


class LoginRequiredMixin(object):
    """
    Simple mixin requiring login
    """
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super(LoginRequiredMixin, self).dispatch(*args, **kwargs)


class SearchListView(BaseListView, FormMixin, TemplateResponseMixin):
    """
    A class-based list view with a search form.
    params:
    search_fields
    order_field
        
    """
    search_fields = []
    order_field = None
    
    def __init__(self, *args, **kwargs):
        self.filtering = False
        super(SearchListView, self).__init__(*args, **kwargs)
            
    
    def get_form_kwargs(self):
        """
        Returns the keyword arguments for instantiating the form.
        """
        update_data ={}
        for fieldname in self.search_fields:
            try:
                has_multiple = self.search_fields[fieldname].get('multiple', False)
            except:
                has_multiple = False
                
            if has_multiple:
                value = self.request.GET.getlist(fieldname, [])
            else:
                value = self.request.GET.get(fieldname, None)

            update_data[fieldname] =  value
            
        if self.order_field:
            update_data[self.order_field] = self.request.GET.get(self.order_field, None)
            
        initial = self.get_initial()
        initial.update(update_data)
        kwargs = {'initial': initial }
        return kwargs
        
        
    
    def get(self, request, *args, **kwargs):
    
        search_errors_fields = []
        search_errors = []
            
        # From ProcessFormMixin
        form_class = self.get_form_class()
        if form_class:
            self.form = self.get_form(form_class)
        else:
            self.form = None
            
            
        # From BaseListView
        self.object_list = self.get_queryset()
        
        # Building search query
        # queries generated by different search_fields are ANDed
        # if a search field is defined for more than one field, are put together with OR
        and_query = None
        
        for fieldname in self.search_fields:
            if fieldname in request.GET and request.GET[fieldname] != '' and request.GET[fieldname] != []:
                or_query = None
                
                if type(self.search_fields[fieldname]) == type(list()):
                    field_list = self.search_fields[fieldname]
                    search_operator = "__icontains"
                    fixed_filters = None           
                    multiple_values = False         
                    custom_query_method = None
                else:
                    field_list = self.search_fields[fieldname]['fields']                
                    search_operator = self.search_fields[fieldname].get('operator', None)
                    fixed_filters = self.search_fields[fieldname].get('fixed_filters', None)
                    multiple_values = self.search_fields[fieldname].get('multiple', False)
                    custom_query_method =  self.search_fields[fieldname].get('custom_query', None)
                
                for model_field in field_list:
                    
                    if multiple_values:
                        request_field_value = request.GET.getlist(fieldname)
                    else:
                        request_field_value = request.GET[fieldname]
                    
                    if not custom_query_method:
                        fieldname_key = model_field + search_operator
                        filter_dict = { fieldname_key : request_field_value}
                        if not or_query:
                            or_query = Q(**filter_dict)
                        else:
                            or_query = or_query | Q(**filter_dict)
                
                    else:
                        cf = custom_query_method(request_field_value)
                        if not or_query:
                            or_query = cf
                        else:
                            or_query = or_query | cf
                        
                
                if fixed_filters:
                    fixed_query = Q(**fixed_filters)
                else:
                    fixed_query = None
                
                if not and_query:
                    and_query = or_query
                else:
                    and_query = and_query & or_query
                    
                if fixed_query:
                    and_query = and_query & fixed_query
                
        
        if and_query:
            self.filtering = True
            try:
                self.object_list = self.object_list.filter(and_query)
            except ValueError, e:
                search_errors.append(str(e))
            
            
        if self.order_field:
            if self.order_field in request.GET and request.GET[self.order_field]:
                order_by = request.GET[self.order_field]
                self.object_list = self.object_list.order_by(order_by)
            

        allow_empty = self.get_allow_empty()
        if not allow_empty:
            # When pagination is enabled and object_list is a queryset,
            # it's better to do a cheap query than to load the unpaginated
            # queryset in memory.
            if (self.get_paginate_by(self.object_list) is not None
                and hasattr(self.object_list, 'exists')):
                is_empty = not self.object_list.exists()
            else:
                is_empty = len(self.object_list) == 0
            if is_empty:
                raise Http404(_("Empty list and '%(class_name)s.allow_empty' is False.")
                        % {'class_name': self.__class__.__name__})
        
        context = super(SearchListView, self).get_context_data(object_list=self.object_list, form=self.form)
        context['filtering'] = self.filtering
        context['search_errors'] = search_errors
        context['search_errors_fields'] = search_errors_fields
        
        if self.form:
            context['cleaned_data'] = self.form.fields
        else:
            context['cleaned_data'] = {}

        return self.render_to_response(context)